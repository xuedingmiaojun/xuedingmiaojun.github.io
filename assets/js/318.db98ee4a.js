(window.webpackJsonp=window.webpackJsonp||[]).push([[318],{604:function(t,a,v){"use strict";v.r(a);var _=v(2),e=Object(_.a)({},function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"setdata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#setdata","aria-hidden":"true"}},[t._v("#")]),t._v(" setData")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("频繁setData（毫秒级）后果")]),t._v(" "),v("ul",[v("li",[t._v("Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层")]),t._v(" "),v("li",[t._v("渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时")])])]),t._v(" "),v("li",[v("strong",[t._v("每次 setData 都传递大量新数据")]),t._v(" "),v("ul",[v("li",[t._v("数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程")])])]),t._v(" "),v("li",[v("strong",[t._v("后台态页面进行 setData")]),t._v(" "),v("ul",[v("li",[t._v("当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行")])])]),t._v(" "),v("li",[v("strong",[t._v("建议")]),t._v(" "),v("ul",[v("li",[t._v("不要频繁调用setData, 尽量合并到一次setData调用")]),t._v(" "),v("li",[t._v("传输数据量跟通信性能有关，尽量少于64k，避免一些不需要在页面展示的复杂数据结构或者长字符串")]),t._v(" "),v("li",[t._v("与界面无关的数据最好不要设置在data中")]),t._v(" "),v("li",[t._v("去掉不必要的事件绑定，减少通信的数据量以及次数")]),t._v(" "),v("li",[t._v("不要在节点data前缀放置过大数据（需要传输target的currentTarget和dataset）"),v("br")])])])]),t._v(" "),v("h3",{attrs:{id:"图片优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图片优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 图片优化")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("图片资源")])]),t._v(" "),v("ul",[v("li",[t._v("主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("图片对内存的影响")])]),t._v(" "),v("ul",[v("li",[t._v("在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收")])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("图片对页面切换的影响")])]),t._v(" "),v("ul",[v("li",[t._v("大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况.建议开发者尽量减少使用大图片资源")])])])]),t._v(" "),v("h3",{attrs:{id:"代码包大小的优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#代码包大小的优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码包大小的优化")]),t._v(" "),v("p",[t._v("有必要尽量减少代码包的大小，因为代码包大小直接影响到下载速度，从而影响用户的首次打开体验。除了代码自身的重构优化外，还可以从这两方面着手优化代码大小：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("控制代码包内图片资源")]),t._v(" "),v("ul",[v("li",[t._v("小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。 但我们分析数据发现，不同小程序之间的代码包压缩比差异也挺大的，部分可以达到 30%，而部分只有 80%，而造成这部分差异的一个原因，就是图片资源的使用。GZIP 对基于文本资源的压缩效果最好，在压缩较大文件时往往可高达 70%-80% 的压缩率，而如果对已经压缩的资源（例如大多数的图片格式）则效果甚微")])])]),t._v(" "),v("li",[v("strong",[t._v("及时清理没有使用到的代码和资源")]),t._v(" "),v("ul",[v("li",[t._v("在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小")])])])])])},[],!1,null,null,null);a.default=e.exports}}]);