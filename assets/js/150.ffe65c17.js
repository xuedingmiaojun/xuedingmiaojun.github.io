(window.webpackJsonp=window.webpackJsonp||[]).push([[150],{437:function(t,s,n){"use strict";n.r(s);var a=n(2),r=Object(a.a)({},function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"js闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" JS闭包")]),t._v(" "),n("div",{staticClass:"tip custom-block"},[n("p",{staticClass:"custom-block-title"},[t._v("闭包概念")]),t._v(" "),n("ul",[n("li",[t._v("能够读取其他函数内部变量的函数")]),t._v(" "),n("li",[t._v("定义在一个函数内部的函数，内部函数持有外部函数内变量的引用")])]),t._v(" "),n("p",[t._v("简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数,但并"),n("strong",[t._v("不仅仅是一个函数，它是一个环境")]),t._v("，这个环境中保存了一些相关的数据及指针引用。")])]),t._v(" "),n("p",[n("strong",[t._v("变量作用域")]),n("br"),t._v("\n两种：全局变量、局部变量。js中函数内部可以读取全局变量，函数外部不能读取函数内部的局部变量。")]),t._v(" "),n("p",[n("strong",[t._v("为什么需要")]),n("br"),t._v("\n局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染")]),t._v(" "),n("p",[n("strong",[t._v("何时使用？")]),n("br"),t._v("\n变量既想反复使用，又想避免全局污染")]),t._v(" "),n("p",[n("strong",[t._v("用法")])]),t._v(" "),n("ul",[n("li",[t._v("定义外层函数，封装被保护的局部变量")]),t._v(" "),n("li",[t._v("定义内层函数，执行对外部函数变量的操作")]),t._v(" "),n("li",[t._v("外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中")])]),t._v(" "),n("p",[t._v("从外部读取函数内部的变量")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("f1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("f2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//f2是一个闭包")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("alert")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" f2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("ul",[n("li",[t._v("js链式作用域：子对象会一级一级向上寻找所有父对象的变量，反之不行。")]),t._v(" "),n("li",[t._v("f2可以读取f1中的变量，只要把f2作为返回值，就可以在f1外读取f1内部变量")])]),t._v(" "),n("p",[n("strong",[t._v("用途")])]),t._v(" "),n("ul",[n("li",[t._v("读取函数内部的变量")]),t._v(" "),n("li",[t._v("让这些变量的值始终保持在内存中。不会再f1调用后被自动清除")]),t._v(" "),n("li",[t._v("方便调用上下文的局部变量。利于代码封装\n"),n("ul",[n("li",[t._v("原因：f1是f2的父函数，f2被赋给了一个全局变量，f2始终存在内存中，f2的存在依赖f1，因此f1也始终存在内存中，不会在调用结束后，被垃圾回收机制回收")])])])])])},[],!1,null,null,null);s.default=r.exports}}]);